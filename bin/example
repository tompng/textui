#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'textui'

class RootComponent < Textui::Component
  def initialize(components)
    @components = components
    @focus = 0
  end

  def cursor_pos
    @components[@focus]&.cursor_pos
  end

  def key_press(key)
    if key.type == :ctrl_i
      @focus = @components.size == 0 ? 0 : (@focus + 1) % @components.size
    else
      @components[@focus]&.key_press(key)
    end
  end

  def tick
    @components.each(&:tick)
  end

  def render
    @components.flat_map(&:render)
  end
end

begin
  puts 'TAB: switch focus'
  puts 'CTRL-C: exit'
  screen = Textui::Screen.new
  box1 = Textui::Box.new(0, 5, 20, 8, title: 'textarea')
  box1.component = Textui::Textarea.new(0, 0, 18, 6)
  box2 = Textui::Box.new(16, 0, 20, 10, title: 'textarea')
  box2.component = Textui::Textarea.new(0, 0, 18, 8)
  root = RootComponent.new([box1, box2])
  box2.component.clickable = true

  screen.render(root)

  Textui::Event.each($stdin, tick: 0.1) do |type, data|
    case type
    when :mouse_down, :mouse_up, :mouse_scroll_down, :mouse_scroll_up
      x, y, component = screen.clickable_at(data[0], data[1])
      component.send(type, x - box2.x - 1, y - box2.y - 1) if component.respond_to?(type)
    when :key
      if data.type == :ctrl_l
        screen.reset_screen
      else
        root.key_press(data)
      end
    when :tick
      root.tick
    when :resize, :resume
      screen.resize
    else
      root.key_press(Textui::InputRecognizer::Key.new :else, [type, data].inspect)
    end
    screen.render(root)
  end
rescue Interrupt
ensure
  screen.cleanup
  puts "\e[1mTEXTAREA1\e[0m"
  puts box1.component.value
  puts "\e[1mTEXTAREA2\e[0m"
  puts box2.component.value
end
