#!/usr/bin/env ruby
# frozen_string_literal: true

require 'bundler/setup'
require 'textui'

class RootComponent < Textui::Container
  def initialize
    super
    @focus = 0
  end

  def cursor_pos
    @components[@focus]&.cursor_pos
  end

  def key_press(key)
    if key.type == :ctrl_i
      @focus = (@focus + 1) % [@components.size, 1].max
    elsif key.type == :shift_tab
      @focus = (@focus - 1) % [@components.size, 1].max
    else
      @components[@focus]&.key_press(key)
    end
  end

  def tick
    @components.each(&:tick)
  end

  def render
    @components.flat_map(&:render)
  end
end

begin
  puts 'TAB: switch focus'
  puts 'CTRL-C: exit'
  screen = Textui::Screen.new
  box1 = Textui::Box.new(20, 8, title: 'textarea')
  textarea1 = Textui::Textarea.new(18, 6)
  box1.add(textarea1, 1, 1)
  box2 = Textui::Box.new(20, 10, title: 'textarea')
  textarea2 = Textui::Textarea.new(18, 8)
  box2.add(textarea2, 1, 1)
  root = Textui::Container.new
  root.add(box1, 0, 5)
  root.add(box2, 16, 0)
  textarea1.clickable = true

  screen.render(root)

  Textui::Event.each($stdin, tick: 0.1) do |type, data|
    case type
    when :mouse_down, :mouse_up, :mouse_scroll_down, :mouse_scroll_up
      x, y, component = screen.clickable_at(data[0], data[1])
      if component && component.respond_to?(type)
        cx, cy = component.absolute_position
        component.send(type, x - cx, y - cy)
      end
    when :key
      if data.type == :ctrl_l
        screen.reset_screen
      else
        root.key_press(data)
      end
    when :tick
      root.tick
    when :resize, :resume
      screen.resize
    else
      root.key_press(Textui::InputRecognizer::Key.new :else, [type, data].inspect)
    end
    screen.render(root)
  end
rescue Interrupt
  screen.cleanup
  puts "\e[1mTEXTAREA1\e[0m"
  puts textarea1.value
  puts "\e[1mTEXTAREA2\e[0m"
  puts textarea2.value
end
